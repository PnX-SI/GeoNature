import { Component, forwardRef, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import {
  AbstractControl,
  ControlValueAccessor,
  FormGroup,
  NG_VALUE_ACCESSOR,
  ReactiveFormsModule,
} from '@angular/forms';
import { FieldMappingService } from '@geonature/modules/imports/services/mappings/field-mapping.service';
import { NgSelectModule } from '@ng-select/ng-select';
import { GN2CommonModule } from '@geonature_common/GN2Common.module';
import { DynamicFormWrapperComponent } from './dynamic-form-wrapper/dynamic-form-wrapper.component';
import { NgbModule } from '@ng-bootstrap/ng-bootstrap';

interface BibField {
  autogenerated: boolean;
  comment: string;
  desc_field: string;
  eng_label: string;
  fr_label: string;
  id_field: number;
  mandatory: false;
  mnemonique?: any;
  mandatory_conditions?: Array<string>;
  name_field: string;
  multi: boolean;
  optional_conditions?: Array<string>;
  type_field: string;
  type_field_params: any;
}

// ////////////////////////////////////////////////////
// Value type
// ////////////////////////////////////////////////////
type Constant = {
  column_src?: never;
  default_value: string;
};
type CSV = {
  column_src: string;
  default_value?: never;
};
type ValueType = Constant | CSV;

export const CUSTOM_CONTROL_VALUE_ACCESSOR: any = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => FieldMappingInputComponent),
  multi: true,
};

@Component({
  standalone: true,
  selector: 'gn-fieldmapping-input',
  templateUrl: './fieldmapping-input.component.html',
  styleUrls: ['./fieldmapping-input.component.scss'],
  imports: [
    CommonModule,
    ReactiveFormsModule,
    NgSelectModule,
    GN2CommonModule,
    DynamicFormWrapperComponent,
    NgbModule,
  ],
  providers: [CUSTOM_CONTROL_VALUE_ACCESSOR],
})
export class FieldMappingInputComponent implements ControlValueAccessor {
  // ////////////////////////////////////////////////////
  // control value accessor
  // ////////////////////////////////////////////////////
  @Input()
  value: ValueType | null = null;
  writeValue(value: ValueType | null): void {
    if (this.value == value) {
      return;
    }
    this.value = value;
    this.updateComponentState();
  }

  onChanged: Function = () => {};
  registerOnChange(fn: Function) {
    this.onChanged = fn;
  }

  onTouched: Function = () => {};
  registerOnTouched(fn: Function) {
    this.onTouched = fn;
  }

  // ////////////////////////////////////////////////////
  // Value selector
  // ////////////////////////////////////////////////////

  updateValue() {
    if (this._csvColumn) {
      this.value = {
        column_src: this._csvColumn,
      };
    } else if (this.constantValue) {
      this.value = {
        default_value: this.constantValue,
      };
    } else {
      this.value = null;
    }
  }

  updateComponentState() {
    if (this._csvColumn != this.value?.column_src) {
      this._csvColumn = this.value?.column_src;
    }
    if (this.constantValue != this.value?.default_value) {
      this.constantValue = this.value?.default_value;
    }
  }

  // //////////////////////////////////////////////////////////////////////////
  // CSV Selector
  // //////////////////////////////////////////////////////////////////////////

  @Input()
  csvColumnNames: Array<string> = [];

  _csvColumn: string | null = null;

  get csvColumn() {
    return this._csvColumn;
  }

  set csvColumn(csvColumn: string | null) {
    if (this._csvColumn == csvColumn) {
      return;
    }

    this._csvColumn = csvColumn;
    if (csvColumn) {
      this.constantValue = null;
    }
    this.updateValue();
    this.onChanged(this.value);
    this.onTouched(true);
  }

  // //////////////////////////////////////////////////////////////////////////
  // Constant value Selector
  // //////////////////////////////////////////////////////////////////////////

  constantValue: string | null = null;

  constantValueEdited(constantValue: string | null) {
    if (this.constantValue == constantValue) {
      return;
    }

    this.constantValue = constantValue;
    if (constantValue) {
      this._csvColumn = null;
    }
    this.updateValue();
    this.onChanged(this.value);
    this.onTouched(true);
  }

  // ////////////////////////////////////////////////////
  // Fields
  // ////////////////////////////////////////////////////
  @Input()
  siblings: Array<BibField> = [];

  @Input()
  set field(field: BibField) {
    this._field = field;
  }
  get field(): BibField {
    return this._field;
  }

  _field: BibField = {
    autogenerated: false,
    comment: '',
    desc_field: '',
    eng_label: '',
    fr_label: '',
    id_field: 0,
    mandatory: false,
    name_field: '',
    multi: false,
    type_field: '',
    type_field_params: null,
  };

  // ////////////////////////////////////////////////////
  // Form
  // ////////////////////////////////////////////////////
  get formGroup(): FormGroup {
    return this.fm.mappingFormGroup;
  }

  get formControl(): AbstractControl {
    return this.formGroup.controls[this.field.name_field];
  }

  // ////////////////////////////////////////////////////
  // ctor
  // ////////////////////////////////////////////////////
  constructor(public fm: FieldMappingService) {}

  // TODO: this should not exist at this level. Too specific
  get shouldDisplaySINPGenerateAlert(): boolean {
    return (
      this._field.name_field === 'unique_id_sinp_generate' &&
      !this.formGroup.get(this._field.name_field).value
    );
  }

  // //////////////////////////////////////////////////////////////////////////
  // Field label
  // //////////////////////////////////////////////////////////////////////////

  _getFieldsLabel(labels: string[]): string[] {
    return labels.map((label) => {
      return this.siblings.find((field) => field.name_field === label)?.fr_label;
    });
  }

  get optionalFieldLabels(): string[] {
    return this._getFieldsLabel(this._field.optional_conditions);
  }

  get mandatoryFieldLabels(): string[] {
    return this._getFieldsLabel(this._field.mandatory_conditions);
  }
}
