import { Component, EventEmitter, Input, Output } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AbstractControl, FormControl, FormGroup, ValidationErrors } from '@angular/forms';
import { FieldMappingService } from '@geonature/modules/imports/services/mappings/field-mapping.service';
import { FormDef } from '@geonature/modules/imports/models/mapping.model';
import { isPlainObject } from 'lodash';
import { GN2CommonModule } from '@geonature_common/GN2Common.module';
import { NgbDateParserFormatter } from '@ng-bootstrap/ng-bootstrap';
import { DataFormService } from '@geonature_common/form/data-form.service';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { BibField } from '../bibfield';

@Component({
  standalone: true,
  selector: 'gn-dynamic-form-wrapper',
  templateUrl: './dynamic-form-wrapper.component.html',
  styleUrls: ['./dynamic-form-wrapper.component.scss'],
  imports: [CommonModule, GN2CommonModule],
})
export class DynamicFormWrapperComponent {
  @Input()
  set value(value: string | null) {
    if (!this._control) {
      return;
    }
    if (!value) {
      this._control.reset();
      return;
    }

    this._denormalizeValue(value).then((normalizedValue) => {
      if (this._control.value == normalizedValue) {
        return;
      }
      this._control.setValue(normalizedValue);
    });
  }

  _normalizeValue(value: any): string {
    if (this.formDef.type_widget === 'nomenclature') {
      // Using the nomenclature's label instead of the ID allows us to avoid modifying the content mapping step.
      return typeof value === 'string' ? value : value?.label_default;
    } else if (this.formDef.type_widget === 'taxonomy') {
      return value?.cd_nom;
    } else if (this.formDef.type_widget === 'date') {
      return this._dateParser.format(value) || undefined;
    }
    return value;
  }

  _denormalizeValue(value: string): Promise<any> {
    if (this.formDef.type_widget === 'date') {
      const newDate = this._dateParser.parse(value);
      return Promise.resolve(newDate);
    } else if (this.formDef.type_widget === 'taxonomy') {
      return this._dfs.getTaxonInfoSynchrone(parseInt(value));
    } else {
      try {
        const json = JSON.parse(value);
        if (typeof json === 'object') {
          const newJson = JSON.stringify(json, null, 2);
          return Promise.resolve(newJson);
        } else {
          return Promise.resolve(value);
        }
      } catch (error) {
        return Promise.resolve(value);
      }
    }
  }

  @Output() valueEdit = new EventEmitter<string>();

  // ////////////////////////////////////////////////////
  // Input
  // ////////////////////////////////////////////////////
  @Input()
  set field(field: BibField) {
    this._field = field;
    this.initFormControl();
    this.updateConstantFormDef();
  }
  get field(): BibField {
    return this._field;
  }

  _field: BibField = {
    autogenerated: false,
    comment: '',
    desc_field: '',
    eng_label: '',
    fr_label: '',
    id_field: 0,
    mandatory: false,
    name_field: '',
    multi: false,
    type_field: '',
    type_field_params: null,
  };
  _control: AbstractControl;

  constructor(
    public fm: FieldMappingService,
    private _dateParser: NgbDateParserFormatter,
    private _dfs: DataFormService
  ) {}

  initFormControl() {
    if (!this._control) {
      this._control = new FormControl(null, [
        (control: AbstractControl): ValidationErrors | null => {
          if (!this.field.multi || control.value == null || control.value == '') {
            return null;
          }
          let isError = false;
          try {
            const json = JSON.parse(control.value);
            if (!isPlainObject(json)) {
              isError = true;
            }
          } catch (error) {
            isError = true;
          }
          return isError ? { invalidJSON: true } : null;
        },
      ]);
      this._control.valueChanges
        .pipe(debounceTime(400), distinctUntilChanged())
        .subscribe((value) => {
          this.valueEdit.emit(this._normalizeValue(value));
        });

      this.formGroup.addControl(this.field.name_field, this._control);
    }
  }

  // //////////////////////////////////////////////////////////////////////////
  // Form Definition
  // //////////////////////////////////////////////////////////////////////////

  readonly DEFAULT_CONSTANT_FORMDEF: FormDef = {
    // attribut_label: 'Valeur constante',
    type_widget: 'text',
  };
  formDef: FormDef = this.DEFAULT_CONSTANT_FORMDEF;

  updateConstantFormDef() {
    this.formDef = {
      ...this.DEFAULT_CONSTANT_FORMDEF,
      attribut_name: `${this._field.name_field}`,
      ...(this._field.type_field_params || {}),
    };
    // Like server side, we use field.mnemonique and field.multi to handle these types of field
    if (this._field.mnemonique || this._field.type_field === 'nomenclature') {
      this.formDef = {
        ...this.formDef,
        type_widget: 'nomenclature',
        code_nomenclature_type: this._field.mnemonique || this.formDef.code_nomenclature_type,
        bind_all_item: true,
      };
      return;
    }
    if (this._field.multi) {
      this.formDef = {
        ...this.formDef,
        type_widget: 'textarea',
      };
      return;
    }
    if (this._field.type_field == 'dataset') {
      this.formDef.creatable_in_module = this.fm.moduleCode;
    }
    this.formDef = {
      ...this.formDef,
      type_widget: this._field.type_field || 'text',
    };
  }

  get formGroup(): FormGroup {
    return this.fm.dynamicFormWrapperFormGroup;
  }
}
