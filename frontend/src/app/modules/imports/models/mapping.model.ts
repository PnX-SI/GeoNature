import { Step } from './enums.model';
import { Cruved } from './cruved.model';

interface Mapping {
  id: number;
  label: string;
  type: string;
  active: boolean;
  public: boolean;
  cruved: Cruved;
}

export interface FormDef {
  type_widget: string;
  [propName: string]: any;
}

export interface Field {
  id_field: number;
  autogenerated: boolean;
  eng_label: string;
  fr_label: string;
  comment: string;
  desc_field: string;
  mandatory: boolean;
  multi: boolean;
  name_field: string;
  mapping_condition: string;
  entity: any;
  type_field: string;
  type_field_params: any;
  mnemonique: string;
  mandatory_conditions: string[];
  optional_conditions: string[];
}

export type FieldMappingItemConstantValue = any;
export type FieldMappingItemConstant = {
  column_src?: never;
  constant_value: FieldMappingItemConstantValue;
};
export type FieldMappingItemCSVValue = string | string[];
export type FieldMappingItemCSV = {
  column_src: FieldMappingItemCSVValue;
  constant_value?: never;
};

export type FieldMappingItem = FieldMappingItemConstant | FieldMappingItemCSV;

/*
  Type insatisfaisant, pas assez contraignant
  L'objectif serait d'avoir, en pseudo code:
  interface FieldMappingValues {
    __preset__: Record<string, FieldMappingItem>
    [propName in string - '__preset__']: FieldMappingItem
  }
  Une limitation de typescript empêche ce type de syntaxe.
  La solution est ce confus 'FieldMappingItem | any',sinon typescript s'emmêle les pinceaux a de multiples endroits
 */
export type FieldMappingValues = Record<string, FieldMappingItem | any>;

export interface FieldMapping extends Mapping {
  values: FieldMappingValues;
}

interface ContentMappingNomenclatureValues {
  [propName: string]: string; // source value: target cd_nomenclature
}

export interface ContentMappingValues {
  [mnemonique: string]: ContentMappingNomenclatureValues;
}

export interface ContentMapping extends Mapping {
  values: ContentMappingValues;
}
