import { Injectable } from '@angular/core';
import {
  FormGroup,
  FormControl,
  Validators,
  AbstractControl,
  ValidationErrors,
  FormBuilder,
  ValidatorFn,
} from '@angular/forms';
import { ImportDataService } from '../data.service';
import { FieldMapping, FieldMappingValues } from '../../models/mapping.model';
import { BehaviorSubject, forkJoin } from 'rxjs';
import { ImportProcessService } from '../../components/import_process/import-process.service';
import { ConfigService } from '@geonature/services/config.service';
import { TaxonTreeComponent } from '@geonature_common/form/taxon-tree/taxon-tree.component';
import { Observable } from 'rxjs-compat';

interface FieldsMappingStatus {
  mapped: Set<string>;
  unmapped: Set<string>;
  autogenerated: Set<string>;
}

@Injectable()
export class FieldMappingService {
  public data: BehaviorSubject<any> = new BehaviorSubject({
    fieldMappings: null,
    targetFields: null,
    sourceFields: null,
  });
  public currentFieldMapping: BehaviorSubject<FieldMapping> = new BehaviorSubject(null);
  public mappingFormGroup: FormGroup;
  private mappingData: Array<FieldMapping>; // Contains all field mappings
  private targetFieldsData: any;
  private sourceFields: Array<string>;
  private fieldMappingStatus: FieldsMappingStatus = {
    mapped: new Set<string>(),
    unmapped: new Set<string>(),
    autogenerated: new Set<string>(),
  };
  public isReady: boolean = false;

  constructor(
    private _fb: FormBuilder,
    private _importDataService: ImportDataService,
    private _importProcessService: ImportProcessService,
    private _configService: ConfigService
  ) {
    this.retrieveData();
  }

  mappingStatus(category: string, item: string) {
    return this.fieldMappingStatus[category].has(item);
  }

  parseData({ fieldMappings, targetFields, sourceFields }) {
    this.targetFieldsData = targetFields;
    this.mappingData = fieldMappings;
    this.sourceFields = sourceFields;

    this.fieldMappingStatus.unmapped = new Set(this.sourceFields);
    this.targetFieldsData.forEach(({ autogenerated, name_field }) => {
      if (autogenerated) {
        this.fieldMappingStatus.autogenerated.add(name_field);
      } else {
        this.fieldMappingStatus.unmapped.add(name_field);
      }
    });
  }

  retrieveData() {
    forkJoin({
      fieldMappings: this._importDataService.getFieldMappings(),
      targetFields: this._importDataService.getBibFields(),
      sourceFields: this._importDataService.getColumnsImport(
        this._importProcessService.getImportData().id_import
      ),
    }).subscribe(({ fieldMappings, targetFields, sourceFields }) => {
      this.data.next({ fieldMappings, targetFields, sourceFields });
    });
  }
  getTargetFieldsData() {
    return this.targetFieldsData;
  }
  getSourceFieldsData() {
    return this.sourceFields;
  }
  getMappings() {
    return this.mappingData;
  }

  initForm() {
    this.mappingFormGroup = this._fb.group({});
    this.createMappingFormValidators();
    this.mappingFormGroup.updateValueAndValidity();
    this.currentFieldMapping.subscribe((fieldMapping) => {
      console.log('fieldMapping: ', fieldMapping);
      if (fieldMapping === null) {
        this.mappingFormGroup.reset();
        for (const field of this.fieldMappingStatus.autogenerated) {
          const control = this.mappingFormGroup.get(field);
          if (
            field !== 'unique_id_sinp_generate' ||
            this._configService.IMPORT.DEFAULT_GENERATE_MISSING_UUID
          ) {
            control.setValue(true);
          }
        }
      } else {
        this.fillFormWithMapping(fieldMapping.values, true);
      }
    });
  }

  createMappingFormValidators(): ValidationErrors | null {
    return null;
  }
  /**
   * Flattens the field mapping data from the given target fields array.
   *
   * @param {any[]} targetFields - The array of target fields containing themes and fields.
   * @return {any[]} The flattened array of field mapping data.
   */
  flattenTargetFieldData(targetFields: any) {
    let flattened = [];
    targetFields.forEach((entity) => {
      entity.themes.forEach(({ fields, theme }) => {
        fields.forEach((field) => {
          flattened.push({ ...field, ...{ entity: entity.label, theme: theme.fr_label_theme } });
        });
      });
    });
    return flattened;
  }

  populateMappingForm() {
    this.flattenTargetFieldData(this.targetFieldsData).forEach(
      ({ name_field, autogenerated, mandatory }) => {
        let control: AbstractControl;
        if (!(name_field in this.fieldMappingStatus.mapped)) {
          // If a control with a given name doesn't exist, create a new one
          const validator: ValidatorFn[] = mandatory ? [Validators.required] : [];
          control = new FormControl(null, validator);
          control.valueChanges.subscribe((value) => {
            this.onFieldMappingChange(name_field, value);
          });
        } else {
          // If a control with a given name already exists, it would not be replaced with a new one.
          // The existing one will be updated with a new obser. We make sure to sync the references of it.
          this.mappingFormGroup.controls[name_field].valueChanges.subscribe((value) => {
            this.mappingFormGroup.controls[name_field].setValue(value, {
              onlySelf: true,
              emitEvent: false,
              emitModelToViewChange: true,
            });
          });
          control = this.mappingFormGroup.controls[name_field];
        }
        this.mappingFormGroup.addControl(name_field, control);
      }
    );
  }

  /**
   * Fill the field form with the value define in the given mapping
   * @param mapping : id of the mapping
   */
  fillFormWithMapping(mappingvalues: FieldMappingValues, fromMapping = false) {
    // Retrieve fields for this mapping

    this.mappingFormGroup.reset();
    Object.entries(mappingvalues as FieldMappingValues).forEach(([target, source]) => {
      let control = this.mappingFormGroup.get(target);
      if (control) {
        if (typeof source === 'object') {
          let value = source;
          let filtered = source.filter((x) => this.sourceFields.includes(x));
          if (filtered.length > 0) {
            value = filtered;
          }
          control.setValue(value);
        } else {
          if (
            !(source in this.sourceFields) &&
            !(target in this.fieldMappingStatus.autogenerated)
          ) {
            return;
          }
          control.setValue(source);
        }

        if (fromMapping) {
          // this.autoMappedFields.push(target);
        }
      }
    });
  }

  onFieldMappingChange(name_field, value) {
    if (value) {
      this.fieldMappingStatus.mapped.add(value);
      this.fieldMappingStatus.unmapped.delete(value);
    } else {
      this.fieldMappingStatus.mapped.delete(name_field);
      this.fieldMappingStatus.unmapped.add(name_field);
    }
  }

  /**
   * Callback when a new mapping is selected
   *
   * @param {FieldMapping} mapping - the selected mapping
   */
  onNewMappingSelected(mapping: FieldMapping = null): void {
    if (mapping === null) {
      this.mappingFormGroup.reset();
      this.fieldMappingStatus.autogenerated.forEach;
      //   for (const field of this.fieldMappingStatus.autogenerated) {
      //     const control = this.mappingFormGroup.get(field);
      //     if (
      //       field !== 'unique_id_sinp_generate' ||
      //       this._configService.IMPORT.DEFAULT_GENERATE_MISSING_UUID
      //     ) {
      //       control.setValue(true);
      //     }
      //   }
      // } else {
      //   this.fillFormWithMapping(mapping.values, true);
      //   this.mappingSelected = true;
    }
  }

  // add a form control for each target field in the mappingForm
  // mandatory target fields have a required validator
  displayAlert(field) {
    return (
      field.name_field === 'unique_id_sinp_generate' &&
      !this.mappingFormGroup.get(field.name_field).value
    );
  }
  /**
   * Add custom validator to the form
   */
  geoFormValidator(g: FormGroup): ValidationErrors | null {
    /* We require a position (wkt/x,y) and/or a attachement (code{maille,commune,departement})
       We can set both as some file can have a position for few rows, and a attachement for others.
       Contraints are:
       - We must have a position or a attachement (or both).
       - WKT and X/Y are mutually exclusive.
       - Code{maille,commune,departement} are mutually exclusive.
    */
    /*
        6 cases :
        - all null : all required
        - wkt == null and both coordinates != null : wkt not required, codes not required, coordinates required
        - wkt != '' : wkt required, coordinates and codes not required
        - one of the code not empty: others not required
        - wkt and X/Y filled => error
        */
    let xy = false;
    let attachment = false;

    let wkt_errors = null;
    let longitude_errors = null;
    let latitude_errors = null;
    let codemaille_errors = null;
    let codecommune_errors = null;
    let codedepartement_errors = null;
    // check for position
    if (g.value.longitude != null || g.value.latitude != null) {
      xy = true;
      // ensure both x/y are set
      if (g.value.longitude == null) longitude_errors = { required: true };
      if (g.value.latitude == null) latitude_errors = { required: true };
    }
    if (g.value.WKT != null) {
      xy = true;
    }
    // check for attachment
    if (
      g.value.codemaille != null ||
      g.value.codecommune != null ||
      g.value.codedepartement != null
    ) {
      attachment = true;
    }
    if (xy == false && attachment == false) {
      wkt_errors = { required: true };
      longitude_errors = { required: true };
      latitude_errors = { required: true };
      codemaille_errors = { required: true };
      codecommune_errors = { required: true };
      codedepartement_errors = { required: true };
    }
    if ('WKT' in g.controls) g.controls.WKT.setErrors(wkt_errors);
    if ('longitude' in g.controls) g.controls.longitude.setErrors(longitude_errors);
    if ('latitude' in g.controls) g.controls.latitude.setErrors(latitude_errors);
    if ('codemaille' in g.controls) g.controls.codemaille.setErrors(codemaille_errors);
    if ('codecommune' in g.controls) g.controls.codecommune.setErrors(codecommune_errors);
    if ('codedepartement' in g.controls)
      g.controls.codedepartement.setErrors(codedepartement_errors);
    // we set errors on individual form control level, so we return no errors (null) at form group level.
    return null;
  }
}
