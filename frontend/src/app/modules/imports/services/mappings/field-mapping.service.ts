import { Injectable } from '@angular/core';
import {
  FormGroup,
  FormControl,
  Validators,
  AbstractControl,
  ValidationErrors,
  FormBuilder,
} from '@angular/forms';
import { ImportDataService } from '../data.service';
import { Field, FieldMapping, FieldMappingValues, FormDef } from '../../models/mapping.model';
import { BehaviorSubject, Subscription, forkJoin } from 'rxjs';
import { ImportProcessService } from '../../components/import_process/import-process.service';
import { ConfigService } from '@geonature/services/config.service';
import { FormService } from '@geonature_common/form/form.service';
import { isPlainObject } from 'lodash';
import { NgbDateParserFormatter } from '@ng-bootstrap/ng-bootstrap';
import { DataFormService } from '@geonature_common/form/data-form.service';

interface FieldsMappingStatus {
  mapped: Set<string>;
  unmapped: Set<string>;
  autogenerated: Set<string>;
}

@Injectable()
export class FieldMappingService {
  /**
   * Observable that emits data related to field mappings.
   * The emitted data has the following shape:
   * - fieldMappings: Array<FieldMapping> | null - All field mappings.
   * - targetFields: any - Data related to target fields.
   * - sourceFields: Array<string> - Names of source fields.
   */
  public data: BehaviorSubject<{
    fieldMappings: Array<FieldMapping> | null;
    targetFields: any;
    sourceFields: Array<string>;
  }> = new BehaviorSubject({
    fieldMappings: null,
    targetFields: null,
    sourceFields: null,
  });

  /**
   * Form control for selecting a field mapping.
   */
  public mappingSelectionFormControl: FormControl = new FormControl(null, []);

  /**
   * Observable that emits the currently selected field mapping.
   */
  public currentFieldMapping: BehaviorSubject<FieldMapping> = new BehaviorSubject(null);

  /**
   * Form group for managing field mappings.
   */
  public mappingFormGroup: FormGroup;

  /**
   * Contains all field mappings.
   */
  private mappingData: Array<FieldMapping>;

  /**
   * Data related to target fields.
   */
  private targetFieldsData: any;

  /**
   * Names of source fields.
   */
  private sourceFields: Array<string>;

  private defaultValueFormDefs: {
    [propName: string]: FormDef;
  } = {};

  private fieldsByEntity: Map<string, Array<string>> = new Map();

  /**
   * Status of field mappings.
   * Contains sets of names of fields mapped, unmapped and autogenerated.
   */
  private fieldMappingStatus: FieldsMappingStatus = {
    mapped: new Set<string>(),
    unmapped: new Set<string>(),
    autogenerated: new Set<string>(),
  };

  private currentFieldMappingSubscription: Subscription;

  /**
   * Flag indicating if the form is ready to be displayed.
   */
  public isReady: boolean = false;

  constructor(
    private _fb: FormBuilder,
    private _importDataService: ImportDataService,
    private _importProcessService: ImportProcessService,
    private _configService: ConfigService,
    private _formservice: FormService,
    private _dateParser: NgbDateParserFormatter,
    private _dataFormService: DataFormService
  ) {}

  /**
   * Checks if a source field is [mapped|unmapped|autogenerated].
   *
   * @param {string} mappingStatus - Field mapping status to check
   * @param {string} targetField - The source field to check
   * @return {boolean} - True if the item is associated with the given status
   */
  checkTargetFieldStatus(mappingStatus: string, targetField: string) {
    return this.fieldMappingStatus[mappingStatus].has(targetField);
  }

  parseData({ fieldMappings, targetFields, sourceFields }) {
    this.targetFieldsData = targetFields;
    this.mappingData = fieldMappings;
    this.sourceFields = sourceFields;

    this.fieldMappingStatus.unmapped = new Set(this.sourceFields);
    this.flattenTargetFieldData(this.targetFieldsData).forEach((field) => {
      if (field.autogenerated) {
        this.fieldMappingStatus.autogenerated.add(field.name_field);
      } else {
        // this.fieldMappingStatus.unmapped.add(name_field);
      }
      this.defaultValueFormDefs[field.name_field] = this.getFieldDefaultValueFormDef(field);
    });
  }

  retrieveData() {
    forkJoin({
      fieldMappings: this._importDataService.getFieldMappings(),
      targetFields: this._importDataService.getBibFields(),
      sourceFields: this._importDataService.getColumnsImport(
        this._importProcessService.getImportData().id_import
      ),
    }).subscribe(({ fieldMappings, targetFields, sourceFields }) => {
      this.data.next({ fieldMappings, targetFields, sourceFields });
    });
  }
  getTargetFieldsData() {
    return this.targetFieldsData;
  }
  getSourceFieldsData() {
    return this.sourceFields;
  }
  getMappings() {
    return this.mappingData;
  }
  getDefaultValueFormDefs() {
    return this.defaultValueFormDefs;
  }

  getUnmappedFieldsLength() {
    return this.getUnmappedFields().length;
  }
  getUnmappedFields() {
    return this.sourceFields.filter((field) => !this.getMappedSourceColumn().includes(field));
  }

  initForm() {
    this.mappingFormGroup = this._fb.group({});
    this.mappingFormGroup.updateValueAndValidity();
  }

  /**
   * Flattens the field mapping data from the given target fields array.
   *
   * @param {any[]} targetFields - The array of target fields containing themes and fields.
   * @return {any[]} The flattened array of field mapping data.
   */
  flattenTargetFieldData(targetFields: any): Field[] {
    let flattened = [];
    targetFields.forEach(({ entity, themes }) => {
      let entityFields = [];
      themes.forEach(({ fields, theme }) => {
        fields.forEach((field) => {
          entityFields.push(field.name_field);
          flattened.push({
            ...field,
            ...{
              entity: {
                label: entity.label,
                parent: entity.parent,
                unique_column: entity.unique_column,
              },
              theme: theme.fr_label_theme,
            },
          });
        });
        this.fieldsByEntity.set(entity.label, entityFields);
      });
    });
    if (this.fieldsByEntity.size > 1)
      this.fieldsByEntity = this.removeCommonStrings(this.fieldsByEntity);
    return flattened;
  }

  /**
   * Removes common strings from each array in the given map and returns a new map with the modified arrays.
   *
   * @param {Map<string, string[]>} map - The map containing arrays of strings.
   * @return {Map<string, string[]>} A new map with the modified arrays.
   */
  removeCommonStrings(map: Map<string, string[]>): Map<string, string[]> {
    const result = new Map<string, string[]>();

    for (const [key, array1] of map) {
      const newArray: string[] = [];

      for (const array2 of map.values()) {
        if (array1 !== array2) {
          for (const str of array1) {
            if (!array2.includes(str)) {
              newArray.push(str);
            }
          }
        }
      }

      result.set(key, newArray);
    }

    return result;
  }

  manageValueChangeMulti(oldValue = [], newValue) {
    for (let value of newValue ? newValue : []) {
      if (!oldValue || !oldValue.includes(value)) {
        this.onFieldMappingChange(value, null);
      }
    }

    for (let value of oldValue ? oldValue : []) {
      if (!newValue || !newValue.includes(value)) {
        this.onFieldMappingChange(null, value);
      }
    }
  }

  /**
   * Populates the mapping form with target field data.
   *
   */
  populateMappingForm() {
    // Populate the form group
    this.flattenTargetFieldData(this.targetFieldsData).forEach(({ name_field, multi }) => {
      let column_src_control: AbstractControl;
      let oldValue = null;
      if (!(name_field in this.mappingFormGroup.controls)) {
        // Control validators will be set in the following iteration
        column_src_control = new FormControl(null, []);
        column_src_control.valueChanges.subscribe((vc) => {
          if (Array.isArray(vc)) this.manageValueChangeMulti(oldValue, vc);
          else this.onFieldMappingChange(vc, oldValue);
          oldValue = vc;
          column_src_control.setValue(vc, { emitEvent: false });
        });
      } else {
        column_src_control = this.mappingFormGroup.controls[name_field];
      }

      let default_value_control: AbstractControl;
      const name_field_default_value = `${name_field}_default_value`;
      if (!(name_field_default_value in this.mappingFormGroup.controls)) {
        default_value_control = new FormControl(null, [
          (control: AbstractControl): ValidationErrors | null => {
            if (!multi || control.value == null || control.value == '') {
              return null;
            }

            let isError = false;
            try {
              const json = JSON.parse(control.value);
              if (!isPlainObject(json)) {
                isError = true;
              }
            } catch (error) {
              isError = true;
            }

            return isError ? { invalidJSON: true } : null;
          },
        ]);
        default_value_control.valueChanges.subscribe((vc) => {
          column_src_control.updateValueAndValidity();
        });
      } else {
        default_value_control = this.mappingFormGroup.controls[name_field_default_value];
      }

      // Reset the control in the form group
      this.mappingFormGroup.addControl(name_field, column_src_control);
      this.mappingFormGroup.addControl(name_field_default_value, default_value_control);
    });

    // Deal with inter-field conditions
    // TODO ? Move the content of this iteration in the previous iteration
    this.flattenTargetFieldData(this.targetFieldsData).forEach(
      ({ name_field, mandatory, mandatory_conditions, optional_conditions, entity }) => {
        if (mandatory_conditions !== null && !mandatory) {
          this.mappingFormGroup
            .get(name_field)
            .setValidators(
              this._formservice.RequiredIfControlIsNotNullValidator(
                mandatory_conditions,
                this.fieldsByEntity.get(entity.label)
              )
            );
        }
        if (optional_conditions !== null && mandatory) {
          this.mappingFormGroup
            .get(name_field)
            .setValidators(
              this._formservice.NotRequiredIfControlIsNotNullValidator(
                optional_conditions,
                this.fieldsByEntity.get(entity.label)
              )
            );
        } else if (mandatory) {
          this.mappingFormGroup
            .get(name_field)
            .setValidators(
              this._formservice.NotRequiredIfNoOther(this.fieldsByEntity.get(entity.label))
            );
        }

        this.mappingFormGroup.get(name_field).valueChanges.subscribe((vc) => {
          Object.keys(this.mappingFormGroup.controls).forEach((k) => {
            this.mappingFormGroup.controls[k].updateValueAndValidity({ emitEvent: false });
          });
        });
      }
    );

    this.currentFieldMappingSubscription = this.currentFieldMapping.subscribe((fieldMapping) => {
      this.fieldMappingStatus = {
        mapped: new Set<string>(),
        unmapped: new Set(this.sourceFields),
        autogenerated: new Set<string>(),
      };

      if (fieldMapping === null) {
        this.mappingFormGroup.reset();
        for (const field of this.fieldMappingStatus.autogenerated) {
          const control = this.mappingFormGroup.get(field);
          if (
            field !== 'unique_id_sinp_generate' ||
            this._configService.IMPORT.DEFAULT_GENERATE_MISSING_UUID
          ) {
            control.setValue(true);
          }
        }
      } else {
        this.fillFormWithMapping(fieldMapping.values, true);
      }
    });
  }

  destroySubscription() {
    this.currentFieldMappingSubscription.unsubscribe();
  }

  /**
   * Fill the field form with the value define in the given mapping
   * @param mapping : id of the mapping
   */
  fillFormWithMapping(mappingvalues: FieldMappingValues, fromMapping = false) {
    // Retrieve fields for this mapping

    this.mappingFormGroup.reset();
    Object.entries(mappingvalues as FieldMappingValues).forEach(async ([target, source]) => {
      let control = this.mappingFormGroup.get(target);
      if (control) {
        if (typeof source.column_src === 'object') {
          let value = source.column_src;
          let filtered = source.column_src.filter((x) => this.sourceFields.includes(x));
          if (filtered.length > 0) {
            value = filtered;
          }
          control.setValue(value);
        } else {
          if (
            this.sourceFields.includes(source.column_src) ||
            target in this.fieldMappingStatus.autogenerated
          ) {
            control.setValue(source.column_src);
          }
        }
      }

      const default_value_control = this.mappingFormGroup.get(`${target}_default_value`);
      if (default_value_control) {
        const formDef = this.defaultValueFormDefs[target];
        if (formDef.type_widget === 'date') {
          return default_value_control.setValue(this._dateParser.parse(source.default_value));
        }
        if (formDef.type_widget === 'taxonomy' && source.default_value) {
          const taxref = await this._dataFormService.getTaxonInfoSynchrone(source.default_value);
          return default_value_control.setValue(taxref);
        }

        try {
          const json = JSON.parse(source.default_value);
          if (typeof json === 'object') {
            default_value_control.setValue(JSON.stringify(json, null, 2));
          } else {
            default_value_control.setValue(source.default_value);
          }
        } catch (error) {
          default_value_control.setValue(source.default_value);
        }
      }
    });
  }

  /**
   * Retrieves the mapped source column values from the mapping form group controls.
   *
   * @return {string[]} Array of unique source column values
   */
  getMappedSourceColumn() {
    let controls = this.mappingFormGroup.controls;
    let controlsKeys = Object.keys(controls);

    return [...new Set(controlsKeys.map((key) => controls[key].value))];
  }

  /**
   * Retrieves the mapped target fields from the mapping form group controls.
   *
   * @return {string[]} An array of unique target field values that are not null
   */
  getMappedTargetFields() {
    let controls = this.mappingFormGroup.controls;
    let controlsKeys = Object.keys(controls);

    return [...new Set(controlsKeys.filter((key) => controls[key].value !== null))];
  }

  onFieldMappingChange(value: any, oldValue: any) {
    if (value) {
      this.fieldMappingStatus.mapped.add(value);
      this.fieldMappingStatus.unmapped.delete(value);
    } else if (oldValue != null) {
      this.fieldMappingStatus.mapped.delete(oldValue);
      this.fieldMappingStatus.unmapped.add(oldValue);
    }
  }

  /**
   * This method check if an autogenerated field was not checked. In this case, we display an alert that
   * indicates to the user that UUID will not be generated.
   * @jacquesfize : In my opinion, should be deleted...
   * @param field
   * @returns
   */
  displayAlert(field) {
    return (
      field.name_field === 'unique_id_sinp_generate' &&
      !this.mappingFormGroup.get(field.name_field).value
    );
  }

  IsEntityMapped(entity, mapped): boolean {
    for (const theme of entity.themes) {
      for (const field of theme.fields) {
        if (mapped.includes(field)) return true;
      }
    }
    return false;
  }

  getFieldDefaultValue(name_field: string, default_value: any) {
    const formDef = this.defaultValueFormDefs[name_field];
    if (formDef.type_widget === 'nomenclature') {
      // Using the nomenclature's label instead of the ID allows us to avoid modifying the content mapping step.
      return typeof default_value === 'string' ? default_value : default_value?.label_default;
    }
    if (formDef.type_widget === 'taxonomy') {
      return default_value?.cd_nom;
    }
    if (formDef.type_widget === 'date') {
      return this._dateParser.format(default_value) || undefined;
    }

    return default_value ?? undefined;
  }

  getFieldDefaultValueFormDef(field: Field): FormDef {
    const def: any = {
      attribut_label: 'Valeur par défaut',
      attribut_name: `${field.name_field}_default_value`,
      ...(field.type_field_params || {}),
    };
    // Like server side, we use field.mnemonique and field.multi to handle these types of field
    if (field.mnemonique || field.type_field === 'nomenclature') {
      return {
        ...def,
        type_widget: 'nomenclature',
        code_nomenclature_type: field.mnemonique || def.code_nomenclature_type,
        bind_all_item: true,
      };
    }
    if (field.multi) {
      return {
        ...def,
        type_widget: 'textarea',
      };
    }

    return {
      ...def,
      type_widget: field.type_field || 'text',
    };
  }
}
